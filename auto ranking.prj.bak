#Version 0.21.1
#Counter: 25
#WinCounter: 1
#BindDebug
#Window 1
#TabInfo
TabText: Layer 0
TabRenamed: 0
TabNumber: 0
TabsetLayer: 0
#Control: Window1
X       : 0
Y       : 0
CX      : 375
CY      : 241
ControlLayer: 0
Title   : Rotmg 21.0.1 Auto Ranking (2)
Class   : Window
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
BkColor : 0
SystemBkColor : BTNFACE
EnableC : 1
DefaultsClass : WS_SYSMENU
Style   : WS_DLGFRAME, WS_SYSMENU, WS_MINIMIZEBOX
TypStyle: {...}
ExStyle : WS_EX_DLGMODALFRAME
Local : 1
LastEditorEvent : 1

#Proc: (General)
include SrvSckIP.ew
include client.ew
include math.ew
include win32extra.ew
include stream_write.ew
include stats.ew

sequence filelist
integer filefound
filefound=0
filelist=dir(current_dir())
for i=3 to length(filelist) do
  if equal(filelist[i][D_NAME],"config.txt") then
  	filefound=1
  end if	
end for

if filefound=0 then
  puts(1,"Current dir is incorrect "&current_dir()&"\n")	
end if

-------called at the start before any code is executed---------------------
function crash(object x)
-- in case of fire ...

    -- (on Linux) send an e-mail containing ex.err
    --system("mail -s \"crash!\" myname@xxx.com < ex.err > /dev/null", 2)
    --puts(1,"crashgodsndsk")
    --?1/0
    clear_screen()
     puts(1,"auto restart in 3 sec\n")
    sleep(3)

    if system_exec("auto_restart.exe", 2) then
      --puts(2, "failure!\n")
    end if
    abort(0)
    return 0
end function

--crash_message("An unexpected error has occurred!\n")
--crash_file("NUL")
crash_routine(routine_id("crash"))
--win32_disable_error_messages=1
-----------------------------------------------------------------------

for i=1 to length(server_list) do
  addItem(combox_serverlist,server_list[i][1])	
end for
setIndex(combox_serverlist,1)


sequence con_email,con_pass,con_owner
con_email=""
con_pass=""
con_owner=""

procedure config_load()
integer fn
fn=open("config.txt","r")
con_email=gets(fn)
con_email=con_email[1..length(con_email)-1]
setText(textbox_email,con_email)
con_pass=gets(fn)
con_pass=con_pass[1..length(con_pass)-1]
setText(textbox_password,con_pass)
con_owner=gets(fn)
con_owner=con_owner[1..length(con_owner)-1]
setText(textbox_owner,con_owner)
setIndex(combox_serverlist,real(gets(fn)))
setCheck(checkbox_auto_connect,real(gets(fn)))
setCheck(checkbox_suicide,real(gets(fn)))
close(fn)	
end procedure
config_load()



atom current_angle, start_time,elasped_time,tx,ty,started_time,lastrealmportal, targetinnexus, lastnexusportal
current_angle=0
start_time=current_time()
started_time=0

atom total_move_time,point_x,point_y
total_move_time=0
point_x=0
point_y=0

lastrealmportal=0
targetinnexus=0
lastnexusportal=0


tx=0
ty=0



include tinyxml.ew
global atom doc
doc= tinyxml_document()
include "account.ew"
--include "equip xml.ew"
include "xml all.ew"
include "ground xml.ew"





global sequence sockets
sockets=repeat(0,65536)

global procedure socket_send_data(integer client,sequence data)
  integer len
  atom socket

  socket=client_list[client][client_socket]

  if sockets[socket]=0 then
    puts(1,"sending data to a closed socket "&sprint(client)&"\n")
    return
  end if

  len=WsockSendData(socket,data)
  if len!=length(data) then
  	puts(1,"sending data as resulted in a error\n")
  	?len
  	puts(1,"socket closed\n")
    WsockCloseSocket(socket)
    sockets[socket]=0

    if len=-10057 or len=-10034 then
      client_set_connected(client,0)
      client_init(client)
      puts(1,"ok checking new error hacking\n")
    end if
  end if

end procedure



include packets.ew
include input_stream.ew
include mapinfo_packet.ew --includes around 10 addional packets
include hello_packet.ew
include text_packet.ew
include load_packet.ew
include create_suc_packet.ew
include realm_packets.ew
include hash.ew
include objects.ew
include projectile.ew
include projectile_enemy.ew



atom speed_mut
speed_mut=1

function speed() --called before speed is required
	atom sp
	sp= (0.004 + (( (client_list[1][client_stats][stat_speed][2]/2)/ 75) * (0.0096 - 0.004)))
	--sp= (0.004 + ( (1/ 75) * (0.0096 - 0.004)))
	return sp*speed_mut
end function

procedure speed_ground()
  integer x,y
  x=floor(client_list[1][client_x])
  y=floor(client_list[1][client_y])

  --if x>0 and y>0 then--bug fix
  	

  --if sequence(ground_delta(map_data[y][x],ground_speed)) then
    --speed_mut = real( ground_delta(map_data[y][x],ground_speed) )
  --else
	--speed_mut = 1
  --end if

  --else
    speed_mut = 1
  --end if

end procedure


--winsocket global vars
global atom hWndMainWindow
hWndMainWindow = getHandle(Window1)
constant SM_ASYNC = #FFFF
integer iwork
iwork = WsockInit()
if iwork = -1 then
  iwork = message_box("WSockInit() failed!","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
  abort(99)
end if

constant stats_size=100
constant stat_empty=repeat({},stats_size)

procedure connect_to_server()
  integer iwork, port
  atom Server_sock,start
  sequence swork,ip

  port = 2050

  iwork=client_not_connected()
  if iwork=0 then --no free clients
    return
  else
	ip=client_list[iwork][client_serverip]
  end if

  Server_sock=Wsock_new(ip, 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

end procedure


	
		
procedure otherhit_packet_write(integer client,atom t, integer bullet_id, integer object_id ,integer target_id)
  sequence data,temp
  data={}

  --bado.writeInt(this.time_); // Int
  --		bado.writeByte(this.bulletId_);
--		bado.writeInt(this.objectId_); // Int-
--		bado.writeInt(this.targetId_); // Int
  data=writeint(data,t)
  data=writebyte(data,bullet_id)
  data=writeint(data,object_id)
  data=writeint(data,target_id)
  temp=reverse(int_to_bytes(length(data)+5)) &otherhit_packet

  data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],data)

  socket_send_data(client,temp&data)
end procedure

procedure playerhit_packet_write(integer client,integer bullet_id, integer owner_id)
  sequence data,temp
  data={}

  data=writebyte(data,bullet_id)
  data=writeint(data,owner_id)
  temp=reverse(int_to_bytes(length(data)+5)) &playerhit_packet

  data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],data)

  socket_send_data(client,temp&data)
end procedure


procedure enemyhit_packet_write(integer client,integer bullet_id, integer target_id, integer killed)
  sequence data,temp
  data={}

  data=writeint(data,current_time())
  data=writebyte(data,bullet_id)
  data=writeint(data,target_id)
  data=writebool(data,killed)
  temp=reverse(int_to_bytes(length(data)+5)) &enemyhit_packet

  data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],data)

  socket_send_data(client,temp&data)
end procedure


procedure projectile_enemy_update_new()
atom dist,period,theta

atom amplitude,frequency

sequence list,object_list
integer bullet_id,ctype,bullet_type,owner_id,object_id
atom x,y,start_time,angle,elapsed_time,vec,modvec,d

integer lifetime,speed

--collision
integer object_type

sequence stats

integer found_solid,object_handle

for i=1 to length(client_list) do

    list=projectile_enemy_get_list(client_list[i][client_projectile_enemy])

    object_list=object_get_list( client_list[i][client_objectlist] )

    for j=1 to length(list) do

      if length(list[j]) then
        x=list[j][projectile_enemy_x]
        y=list[j][projectile_enemy_y]
        angle=list[j][projectile_enemy_angle]
        start_time=list[j][projectile_enemy_start_time]
        bullet_id=list[j][projectile_enemy_bullet_id]
        ctype=list[j][projectile_enemy_type]
        bullet_type=list[j][projectile_enemy_bullet_type] --index into projectile id
        owner_id=list[j][projectile_enemy_owner_id]


        --object_projectile_delta( integer index, integer bullettype ,integer id )
        lifetime=real(object_projectile_delta(ctype, bullet_type,object_projectile_lifetime))
        speed=real(object_projectile_delta(ctype, bullet_type ,object_projectile_speed))

      	elapsed_time=current_time()-start_time
      	if elapsed_time>=lifetime then
      	  projectile_enemy_free(client_list[i][client_projectile_enemy],j)
	    else
	
            dist = (elapsed_time / 1000.0) * (speed / 10.0)
            if is_even(bullet_id) then
              period=0
            else
              period=PI
            end if

            if sequence(object_projectile_delta(ctype, bullet_type,object_projectile_wavy)) then
              theta = angle + (PI * 64) * sin(period + 6 * PI * (elapsed_time / 1000))
              x += dist * cos(theta)
              y += dist * sin(theta)
            elsif sequence(object_projectile_delta(ctype, bullet_type,object_projectile_parametric)) then
              puts(1,"parametric\n")	
            else
              if sequence(object_projectile_delta(ctype, bullet_type,object_projectile_boomerang)) then
                puts(1,"boomerang\n")
              end if
              x += dist * cos(angle)
              y += dist * sin(angle)
              if sequence(object_projectile_delta(ctype, bullet_type,object_projectile_amplitude)) then
                --puts(1,"amplitude\n")
                amplitude=real(object_projectile_delta(ctype, bullet_type,object_projectile_amplitude))
                frequency=real(object_projectile_delta(ctype, bullet_type,object_projectile_frequency))

                d = amplitude * sin(period + elapsed_time / lifetime * frequency * 2 * PI)
                x += d * cos(angle + PI / 2)
                y += d * sin(angle + PI / 2)

              end if
            end if

          found_solid=0
          	

          for k=1 to length(object_list) do
   	        if length(object_list[k]) then
   	          object_type=object_get_type(client_list[i][client_objectlist],k)
   	          if sequence(object_delta(object_type,object_OccupySquare)) or  sequence(object_delta(object_type,object_EnemyOccupySquare))  then
          	  	if point_distance(x,y,object_get_x(client_list[i][client_objectlist],k),object_get_y(client_list[i][client_objectlist],k))<1 then
          	      projectile_enemy_free(client_list[i][client_projectile_enemy],j)
          	      --map_.gs_.gsc_.otherHit(_arg1, this.bulletId_, this.ownerId_, _-1Ub.obj_.objectId_);
          	      otherhit_packet_write(i,current_time(), bullet_id, owner_id ,object_get_id(client_list[i][client_objectlist],k))
          	      --puts(1,"other hit \n")
          	
          	      found_solid=1
          	      exit
          	    end if
              end if

              --if sequence(object_delta(object_type,object_class)) then
              --  if equal(object_delta(object_type,object_class), "Player") and object_get_id(client_list[i][client_objectlist],k)!=client_list[i][client_object_id] then
          	  --    if point_distance(x,y,object_get_x(client_list[i][client_objectlist],k),object_get_y(client_list[i][client_objectlist],k))<1 then
          	  --      projectile_enemy_free(client_list[i][client_projectile_enemy],j)
          	  --      playerhit_packet_write(i,bullet_id, owner_id)
          	  --      puts(1,"another player hit\n")
          	  --      found_solid=1
          	  --      exit
          	  --    end if
              --  end if
          	  --end if
          	
            end if
          end for

          if found_solid=0 then--check the projectile is colliding with the player

             if point_distance(x,y,client_list[i][client_x],client_list[i][client_y])<0.5 then
                  --stats=object_get_stats(client_list[i][client_objectlist],k)
          	   playerhit_packet_write(i,bullet_id, owner_id)
          	   projectile_enemy_free(client_list[i][client_projectile_enemy],j)
          	   --puts(1,"player hit\n")
          	 end if
          	      --exit
          	    --end if
          end if

      	end if

      end if	

    end for

end for



end procedure








procedure projectile_update_new()
atom dist,period,theta

atom amplitude,frequency

sequence list,object_list
integer bullet_id,ctype
atom x,y,start_time,angle,elapsed_time,vec,modvec,d

integer lifetime,speed

--collision
integer object_type

sequence stats

integer found_solid

for i=1 to length(client_list) do

    list=projectile_get_list(client_list[i][client_projectile])

    object_list=object_get_list( client_list[i][client_objectlist] )

    for j=1 to length(list) do

      if length(list[j]) then
        x=list[j][projectile_x]
        y=list[j][projectile_y]
        angle=list[j][projectile_angle]
        start_time=list[j][projectile_start_time]
        bullet_id=list[j][projectile_bullet_id]
        ctype=list[j][projectile_type]

        lifetime=real(object_delta(ctype, object_lifetime))
        speed=real(object_delta(ctype, object_speed))

      	elapsed_time=current_time()-start_time
      	if elapsed_time>=lifetime then
      	  projectile_free(client_list[i][client_projectile],j)
	    else
	
            dist = (elapsed_time / 1000.0) * (speed / 10.0)
            if is_even(bullet_id) then
              period=0
            else
              period=PI
            end if

            if sequence(object_delta(ctype,object_wavy)) then
              theta = angle + (PI * 64) * sin(period + 6 * PI * (elapsed_time / 1000))
              x += dist * cos(theta)
              y += dist * sin(theta)
            else
              x += dist * cos(angle)
              y += dist * sin(angle)
              if sequence(object_delta(ctype,object_amplitude)) then
                --puts(1,"amplitude\n")
                amplitude=real(object_delta(ctype,object_amplitude))
                frequency=real(object_delta(ctype,object_frequency))

                d = amplitude * sin(period + elapsed_time / lifetime * frequency * 2 * PI)
                x += d * cos(angle + PI / 2)
                y += d * sin(angle + PI / 2)

              end if
            end if

          found_solid=0
          for k=1 to length(object_list) do
   	        if length(object_list[k]) then
   	          object_type=object_get_type(client_list[i][client_objectlist],k)
   	          if sequence(object_delta(object_type,object_OccupySquare)) then
          	  	if point_distance(x,y,object_get_x(client_list[i][client_objectlist],k),object_get_y(client_list[i][client_objectlist],k))<1 then
          	      projectile_free(client_list[i][client_projectile],j)
          	      found_solid=1
          	      exit
          	    end if
              end if
            end if
          end for

          if found_solid=0 then
            for k=1 to length(object_list) do
   	        if length(object_list[k]) then
   	          object_type=object_get_type(client_list[i][client_objectlist],k)
          	  if sequence(object_delta(object_type,object_enemy)) then
   	
                if point_distance(x,y,object_get_x(client_list[i][client_objectlist],k),object_get_y(client_list[i][client_objectlist],k))<0.5 then
                  stats=object_get_stats(client_list[i][client_objectlist],k)
                  --?stats[2]

                  if real(object_delta(ctype,object_mindamage))>stats[2][2] then
                  	enemyhit_packet_write( i, bullet_id,  object_get_id(client_list[i][client_objectlist],k),1)
                  	puts(1,"enemy killed\n")
                  else
                    enemyhit_packet_write( i, bullet_id,  object_get_id(client_list[i][client_objectlist],k),0)
                  end if
          	
          	      projectile_free(client_list[i][client_projectile],j)
          	      exit
          	    end if
              end if
            end if
            end for
          end if

      	end if

      end if	

    end for

end for



end procedure


function rate_of_fire(integer ctype)
atom rate
  if sequence(object_delta(ctype,object_rateoffire)) then
    rate= (0.0015 + ((client_list[1][client_stats][stat_dex][2] / 75) * (0.008 - 0.0015)))
    return ((1 / rate) * (1 / real(object_delta(ctype,object_rateoffire))))
  end if
end function



procedure playershoot_packet_write(integer client, integer ctype, atom angle)
sequence data,temp
  atom tt,ret
  integer numprojectiles
  data={}

  numprojectiles=1

  if client_list[client][client_shoot_time]<current_time() then
    client_list[client][client_shoot_time]=current_time()+rate_of_fire(ctype)
  else
    return
  end if


  if ctype=-1 then--new 14/03/2014
  	return
  end if



  if sequence(object_delta(ctype,object_numprojectiles)) then
    numprojectiles=real( object_delta(ctype,object_numprojectiles) )

  end if

  for i=1 to numprojectiles do
  	data={}

  tt=current_time()
  data=writeint(data,tt)
  data=writebyte(data,client_list[client][client_bullet_id])

  client_list[client][client_bullet_id]+=1
  if client_list[client][client_bullet_id]>=128 then
  	client_list[client][client_bullet_id]=0
  end if

  data=writeshort(data,ctype)
  data=writefloat(data,client_list[client][client_x])
  data=writefloat(data,client_list[client][client_y])

  data=writefloat(data,angle)

  ret=projectile_enter(client_list[client][client_projectile],client_list[client][client_x],client_list[client][client_y], angle, tt,client_list[client][client_bullet_id]-1, ctype )

  temp=reverse(int_to_bytes(length(data)+5)) &playershoot_packet

  data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],data)

  socket_send_data(client,temp&data)

  end for

		
end procedure

procedure useitem_packet_write(integer client,integer otype, integer utype)

		
  sequence data,temp
  atom tt
  object ret
  data={}
  tt=current_time()
  data=writeint(data,tt)
  --item
  data=writeint(data,client_list[client][client_object_id])
  data=writebyte(data,1)
  data=writeshort(data,otype)
  --end item
  data=writefloat(data,client_list[client][client_x])
  data=writefloat(data,client_list[client][client_y])
  data=writebyte(data,utype)


  temp=reverse(int_to_bytes(length(data)+5)) &useitem_packet

  data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],data)
  socket_send_data(client,temp&data)

end procedure



procedure find_portal(integer client, atom x, atom y)
   sequence list,stats
   integer object_type
   sequence portal_list,temp2
   atom dist,temp
   integer index
   portal_list={}
   dist=10
   index=0

   list=object_get_list( client_list[client][client_objectlist] )
   for i=1 to length(list) do
   	 if length(list[i]) then
   	   object_type=object_get_type(client_list[client][client_objectlist],i)
   	
   	   --if sequence(object_delta(object_type,object_enemy)) then
       -- puts(1,object_delta(object_type,object_idd)&"\n")	
       --end if

       if sequence(object_delta(object_type,object_idd)) then
         if equal(object_delta(object_type,object_idd), "Nexus Portal") then
           --todo
           --check the protal as room avaiable to enter

           stats=object_get_stats(client_list[client][client_objectlist],i)

           for k=1 to length(stats[32][3]) do
             if stats[32][3][k]='/'  then
      		
      		  if real(stats[32][3][k-2..k-1])<78 then
      		    portal_list=append(portal_list,{object_get_x(client_list[client][client_objectlist],i),object_get_y(client_list[client][client_objectlist],i),object_get_id(client_list[client][client_objectlist],i), object_type,stats[stat_name][3]})
      		  end if
	
      		  exit
             end if
      	   end for
      	
         end if
       end if
   	 end if
  end for

  if length(portal_list) then
  	

    for i=1 to length(portal_list) do
  	  temp=point_distance(x,y,portal_list[i][1],portal_list[i][2])
  	  --?temp
  	  if temp<dist then
  	    index=i
	    dist=temp
  	  end if
    end for

    if index!=0 then
      lastrealmportal=portal_list[index][3]
      if equal(object_delta(portal_list[index][4],object_idd), "Nexus Portal") then
        lastnexusportal=lastrealmportal
      end if
      useportal_packet_write(client, portal_list[index][3])	
      puts(1,portal_list[index][5]&"\n")
    else
      --if equal(map_name,"Nexus")=0  then
      --  temp2=reverse(int_to_bytes(length("")+5)) &escape_packet
      --  socket_send_data(client,temp2)
        --lastrealmportal=0
      --end if
    end if

    --puts(1,"done\n")
    --?index
  end if



end procedure

function enemy_closest(integer client, atom x, atom y)
   sequence list,stats
   integer object_type
   sequence portal_list
   atom dist,temp
   integer index
   portal_list={}
   dist=10
   index=0

   list=object_get_list( client_list[client][client_objectlist] )
   for i=1 to length(list) do
   	 if length(list[i]) then
   	   object_type=object_get_type(client_list[client][client_objectlist],i)
   	
       if sequence(object_delta(object_type,object_enemy)) then
         stats=object_get_stats(client_list[client][client_objectlist],i)
         portal_list=append(portal_list,{object_get_x(client_list[client][client_objectlist],i),object_get_y(client_list[client][client_objectlist],i),object_get_id(client_list[client][client_objectlist],i), i })
       end if

   	 end if
  end for	

  if length(portal_list) then
  	

    for i=1 to length(portal_list) do
  	  temp=point_distance(x,y,portal_list[i][1],portal_list[i][2])
  	  --?temp
  	  if temp<dist then
  	    index=i
	    dist=temp
  	  end if
    end for

    if index!=0 then
      return portal_list[index][4]
    end if

    --puts(1,"done\n")
    --?index
  end if

  return 0

end function



function enemy_closest2(integer client, atom x, atom y)
   sequence list,stats
   integer object_type
   sequence portal_list
   atom dist,temp
   integer index
   portal_list={}
   dist=30
   index=0

   list=object_get_list( client_list[client][client_objectlist] )
   for i=1 to length(list) do
   	 if length(list[i]) then
   	   object_type=object_get_type(client_list[client][client_objectlist],i)
   	
       if sequence(object_delta(object_type,object_enemy)) then
         stats=object_get_stats(client_list[client][client_objectlist],i)
         portal_list=append(portal_list,{object_get_x(client_list[client][client_objectlist],i),object_get_y(client_list[client][client_objectlist],i),object_get_id(client_list[client][client_objectlist],i), i })
       end if

   	 end if
  end for	

  if length(portal_list) then
  	

    for i=1 to length(portal_list) do
  	  temp=point_distance(x,y,portal_list[i][1],portal_list[i][2])
  	  --?temp
  	  if temp<dist then
  	    index=i
	    dist=temp
  	  end if
    end for

    if index!=0 then
      return portal_list[index][4]
    end if

    --puts(1,"done\n")
    --?index
  end if

  return 0

end function


function enemy_near(integer client, atom x, atom y)
   sequence list,stats
   integer object_type
   sequence portal_list
   atom dist,temp
   integer index
   portal_list={}
   dist=30
   index=0

   list=object_get_list( client_list[client][client_objectlist] )
   for i=1 to length(list) do
   	 if length(list[i]) then
   	   object_type=object_get_type(client_list[client][client_objectlist],i)
   	
       if sequence(object_delta(object_type,object_enemy)) then
         stats=object_get_stats(client_list[client][client_objectlist],i)
         portal_list=append(portal_list,{object_get_x(client_list[client][client_objectlist],i),object_get_y(client_list[client][client_objectlist],i),object_get_id(client_list[client][client_objectlist],i), i })
       end if

   	 end if
  end for	


  return length(portal_list)


end function


function player_slottypes(sequence data)
sequence temp
integer pos
  pos=1
  temp={}
	for i=1 to length(data) do
      if data[i]=',' then
		temp&=real(data[pos..i-1])
		pos=i+1 	
	  end if
	end for
	return temp
end function

integer loot_bag_found,loot_bag_id
loot_bag_found=0
loot_bag_id=0


procedure update_packet_first(integer client,integer inputstream)
  object object_type,object_id
  integer loc,inputstream2,statdata_size,statdata_type
  sequence data,stats
  atom x,y
  integer object_handle

  inputstream2 = input_stream_new()
  data=input_stream_slice(inputstream, 1,client_list[client][client_packet_len]-5 )

  --?length(data)
  --?client_list[client][client_packet_len]
  --?length(input_stream_slice(inputstream, client_list[client][client_packet_len], input_stream_length(inputstream)))
  --?client_list[client][client_object_type]
  --?client_list[client][client_object_id]

  object_type=int_to_bytes(client_list[client][client_create_object_type])
  object_id=int_to_bytes(client_list[client][client_object_id])

  loc=match({object_type[2], object_type[1], object_id[4],object_id[3],object_id[2],object_id[1]}, data)
  if loc=0 then
  	puts(1,"a serious error as happend\n")
  	return
  end if

  input_stream_set(inputstream2, data[loc..length(data)])	


  input_stream_set(inputstream, input_stream_slice(inputstream, client_list[client][client_packet_len]-4, input_stream_length(inputstream)) )	


      stats=stat_empty --the most number of stats a object can have

      object_type=input_stream_readshort(inputstream2)
      object_id=input_stream_readint(inputstream2)
      x=input_stream_readfloat(inputstream2)
      y=input_stream_readfloat(inputstream2)
      statdata_size=input_stream_readshort(inputstream2)

      for j=1 to statdata_size do
      	statdata_type=input_stream_readbyte(inputstream2)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 or statdata_type=38 or statdata_type=54 then
          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream2)}
        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream2),0}
        end if
      end for

      object_handle=object_enter(client_list[client][client_objectlist],x,y,object_id,object_type, stats)
      hash_insert(client_list[client][client_hash],hash_index(object_id),object_id,object_handle )

        client_list[client][client_stats]=stats
        client_list[client][client_object_type]=object_type
        client_list[client][client_x]=x
        client_list[client][client_y]=y
        client_list[client][client_tx]=x
        client_list[client][client_ty]=y
        client_list[client][client_last_move_time]=current_time()

  input_stream_delete(inputstream2)
end procedure

procedure update_packet_read(integer client,integer inputstream)
  --tiles
  sequence tiles
  integer tile_size,typee
  atom x,y

  --newobjs
  sequence newobjs,stats
  integer newobj_size,object_type,object_id,statdata_size,statdata_type
  integer dropsize

  sequence data,write,temp

  --new 27/02/2014
  integer object_handle

  --new 11/03/2014
  sequence slottypes,mystats
  integer slottype,tier1,tier2

  temp=reverse(int_to_bytes(length("")+5)) &updateatt_packet
  socket_send_data(client,temp)

  if client_list[client][client_first_update]=0 then
  	client_list[client][client_first_update]=1
  	update_packet_first(client, inputstream)
  	return
  end if

  tile_size=input_stream_readshort(inputstream)
  tiles={}

  if tile_size!=0 then --tiles
  	for i=1 to tile_size do
  	  x=input_stream_readshort(inputstream)
  	  y=input_stream_readshort(inputstream)
  	  typee=input_stream_readshort(inputstream)
  	  if x>0 and y>0 then--bug fix 13/03/2014
  	  	--map_data[y][x]=typee
  	  end if
    end for
  end if

  newobj_size=input_stream_readshort(inputstream)
  newobjs={}

  mystats=client_list[client][client_stats]


  if newobj_size!=0 then --newobjs
  	for i=1 to newobj_size do
      stats=stat_empty --the most number of stats a object can have

      object_type=input_stream_readshort(inputstream)
      object_id=input_stream_readint(inputstream)
      x=input_stream_readfloat(inputstream)
      y=input_stream_readfloat(inputstream)
      statdata_size=input_stream_readshort(inputstream)

      for j=1 to statdata_size do
      	statdata_type=input_stream_readbyte(inputstream)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 or statdata_type=38 or statdata_type=54 then
          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}
        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
        end if
      end for

      object_handle=object_enter(client_list[client][client_objectlist],x,y,object_id,object_type, stats)
      hash_insert(client_list[client][client_hash],hash_index(object_id),object_id,object_handle )


      if sequence(object_delta(object_type,object_idd)) then
       --auto loot equipment
       if equal(object_delta(object_type,object_idd),"Loot Bag")
       or equal(object_delta(object_type,object_idd),"Soulbound Loot Bag")
       or equal(object_delta(object_type,object_idd),"Loot Bag 2")
       or equal(object_delta(object_type,object_idd),"Loot Bag 3")
       or equal(object_delta(object_type,object_idd),"Loot Bag 4")
       or equal(object_delta(object_type,object_idd),"Loot Bag 5")
       or equal(object_delta(object_type,object_idd),"Loot Bag Boost") then
         --puts(1,object_delta(client_list[client][client_object_type],object_slotTypes)&"\n"	)

         slottypes=player_slottypes(object_delta(client_list[client][client_object_type],object_slotTypes))
         if loot_bag_found=0 then

           for j=9 to 9+7 do

      	     if stats[j][2]!=-1 then
      	     if sequence(object_delta(stats[j][2],object_slotType)) then
      	       --if equal(object_delta(object_type,object_idd),"Loot Bag 3") then
                 --puts(1,object_delta(stats[j][2],object_idd)&"\n")
               --end if	
      	
      	       slottype=real(object_delta(stats[j][2],object_slotType))
               for k=1 to 4 do
                 if slottype=slottypes[k] then
                   if mystats[8+k][2]=-1 then
              	     loot_bag_found=1
                     loot_bag_id=object_id
                     client_list[client][client_tx]=x
                     client_list[client][client_ty]=y
                   else
                     if sequence(object_delta(mystats[8+k][2],object_tier)) and sequence(object_delta(stats[j][2],object_tier))  then
                     	
                     tier1= real(object_delta(mystats[8+k][2],object_tier))
                     tier2= real(object_delta(stats[j][2],object_tier))
                     --puts(1,"tire1: "&sprint(tier1)&"\n" )
                     --puts(1,"tire2: "&sprint(tier2)&"\n" )
             	     if tier2>tier1 then
             	       loot_bag_found=1
                       loot_bag_id=object_id
                       client_list[client][client_tx]=x
                       client_list[client][client_ty]=y	
             	     end if
             	     end if
             	   end if
	
                 end if
               end for

             end if
             end if

           end for

         end if

       end if

     end if



      if object_id=client_list[client][client_object_id] then
        client_list[client][client_stats]=stats
        client_list[client][client_object_type]=object_type
        client_list[client][client_x]=x
        client_list[client][client_y]=y
        client_list[client][client_tx]=x
        client_list[client][client_ty]=y
        client_list[client][client_last_move_time]=current_time()
      end if
    end for
  end if


  dropsize=input_stream_readshort(inputstream)
  for i=1 to dropsize do
  	 object_id=input_stream_readint(inputstream)
  	
     if loot_bag_found=1 and loot_bag_id=object_id then
     	
       loot_bag_found=0
       loot_bag_id=0
     	
     end if

     if questobjid=object_id then
     	puts(1,"quest object id destoryed\n")
     	questobjid=0
     end if
  	
  	 object_handle=hash_get_handle(client_list[client][client_hash],hash_index(object_id),object_id)
  	 if object_handle!=0 then
  	   hash_remove_index(client_list[client][client_hash],hash_index(object_id),object_id)
       object_free(client_list[client][client_objectlist],object_handle)
  	 end if
  end for
end procedure
packet_read_id[update_packet+1]=routine_id("update_packet_read")




procedure inv_swap(sequence myslot, sequence there_slot, integer myid, integer thereid, atom x, atom y, integer client)
  sequence write,temp

  write=""
  write=writeint(write,current_time())
  --position
  write=writefloat(write,x)
  write=writefloat(write,y)


  write=writeint(write,myid)
  write=writebyte(write,myslot[1]-8)
  write=writeshort(write,myslot[2])

  write=writeint(write,thereid)
  write=writebyte(write,there_slot[1]-8)
  write=writeshort(write,there_slot[2])

  temp=reverse(int_to_bytes(length(write)+5)) &invswap_packet
  write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
  socket_send_data(client,temp&write)
end procedure


procedure invresult_packet_read(integer client,integer inputstream)
  sequence mystats
  object res
  integer autoloot_handle
  res=input_stream_readint(inputstream)
  puts(1,"invresult\n")
  ?res
  if res=0 then

  end if


end procedure

packet_read_id[invresult_packet+1]=routine_id("invresult_packet_read")


atom teleport_time
teleport_time=0

procedure player_teleport(integer client, integer target_id)
sequence data,temp
  data={}

  	data=writeint(data,target_id)
    temp=reverse(int_to_bytes(length(data)+5)) &teleport_packet

    data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],data)
    socket_send_data(client,temp&data)
end procedure


integer level_20_reached
level_20_reached=0


procedure new_tick_packet_read(integer client,integer inputstream)
  integer size,tick_id,tick_time
  sequence temp,write,stats,data,mystats

  integer object_id,statdata_size,statdata_type
  atom x,y,ttime,speed,stime,SPEED

  --new 27/02/2014
  integer object_handle,object_type

  --new 11/03/2014
  sequence slottypes
  integer slottype,tier1,tier2

  --new 14/03/2014
  integer angle


  tick_id=input_stream_readint(inputstream)
  tick_time=input_stream_readint(inputstream)
  size=input_stream_readshort(inputstream)


  stats=stat_empty --the most number of stats a object can have

  mystats=client_list[client][client_stats]

  for i=1 to size do

    object_id=input_stream_readint(inputstream)
    x=input_stream_readfloat(inputstream)
    y=input_stream_readfloat(inputstream)

    object_handle=hash_get_handle(client_list[client][client_hash],hash_index(object_id),object_id)
    if object_handle!=0 then
      stats=object_get_stats(client_list[client][client_objectlist],object_handle)
      object_type=object_get_type(client_list[client][client_objectlist],object_handle)	
    end if


    statdata_size=input_stream_readshort(inputstream)
    for j=1 to statdata_size do
      statdata_type=input_stream_readbyte(inputstream)
      if statdata_type=31 or statdata_type=62 or statdata_type=82 or statdata_type=38 or statdata_type=54 then
        stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}
      else
        stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
      end if
    end for


    if object_handle!=0 then
    object_set_stats(client_list[client][client_objectlist],object_handle,x,y,stats)

    if sequence(object_delta(object_type,object_class)) and loot_bag_found=0 and level_20_reached=1 then
      if equal(object_delta(object_type,object_class), "Player") then
        if stats[8][2]>=20 and object_id!=client_list[client][client_object_id] then --player stat>20

         if equal(map_name,"Nexus")=0 and teleport_time<current_time() and point_distance(client_list[client][client_x],client_list[client][client_y],client_list[client][client_tx],client_list[client][client_ty])>20 then
           player_teleport(client,object_id)
           teleport_time=current_time()+(1000*30)
         end if

        end if
      end if
    end if



     if sequence(object_delta(object_type,object_idd)) then
       --auto loot equipment
       if equal(object_delta(object_type,object_idd),"Loot Bag")
       or equal(object_delta(object_type,object_idd),"Soulbound Loot Bag")
       or equal(object_delta(object_type,object_idd),"Loot Bag 2")
       or equal(object_delta(object_type,object_idd),"Loot Bag 3")
       or equal(object_delta(object_type,object_idd),"Loot Bag 4")
       or equal(object_delta(object_type,object_idd),"Loot Bag 5")
       or equal(object_delta(object_type,object_idd),"Loot Bag Boost") then
         --puts(1,object_delta(client_list[client][client_object_type],object_slotTypes)&"\n"	)

         slottypes=player_slottypes(object_delta(client_list[client][client_object_type],object_slotTypes))
         if loot_bag_found=0 then

           for j=9 to 9+7 do

      	     if stats[j][2]!=-1 then
      	     if sequence(object_delta(stats[j][2],object_slotType)) then
      	       --if equal(object_delta(object_type,object_idd),"Loot Bag 3") then
                 --puts(1,object_delta(stats[j][2],object_idd)&"\n")
               --end if	
      	
      	       slottype=real(object_delta(stats[j][2],object_slotType))
               for k=1 to 4 do
                 if slottype=slottypes[k] then
                   if mystats[8+k][2]=-1 then
              	     loot_bag_found=1
                     loot_bag_id=object_id
                     client_list[client][client_tx]=x
                     client_list[client][client_ty]=y
                   else
                     if sequence(object_delta(mystats[8+k][2],object_tier)) and sequence(object_delta(stats[j][2],object_tier))  then
                     	
                     tier1= real(object_delta(mystats[8+k][2],object_tier))
                     tier2= real(object_delta(stats[j][2],object_tier))
                     --puts(1,"tire1: "&sprint(tier1)&"\n" )
                     --puts(1,"tire2: "&sprint(tier2)&"\n" )
             	     if tier2>tier1 then
             	       loot_bag_found=1
                       loot_bag_id=object_id
                       client_list[client][client_tx]=x
                       client_list[client][client_ty]=y	
             	     end if
             	     end if
             	   end if
	
                 end if
               end for

             end if
             end if

           end for

         end if

       end if

     end if

   end if-- object handle

    if object_id=questobjid then
      --puts(1,"quest object id\n")
      --?x
      --?y	
    end if

    if object_id=client_list[client][client_object_id] then

      if length(stats[8]) then
        if stats[8][2]>=20 and isChecked(checkbox_suicide)=1 then --level changed to 20
          level_20_reached=1
        end if
      end if

      --auto nexus at 50 percent
      if length(stats[stat_health]) then
        if stats[stat_health][2]<floor(stats[stat_max_health][2]/2) and equal(map_name,"Nexus")=0 and level_20_reached=0 then
          temp=reverse(int_to_bytes(length("")+5)) &escape_packet
          socket_send_data(client,temp)
          puts(1,"auto nexus at 50 percent\n")
        end if
      end if

      if length(stats[stat_mana]) and  level_20_reached=0 and equal(map_name,"Nexus")=0 then
        if client_list[client][client_stats][stat_inv2][2]!=-1 then
          if sequence(object_delta(client_list[client][client_stats][stat_inv2][2],object_mpcost)) then
          	if stats[stat_mana][2]>=real(object_delta(client_list[client][client_stats][stat_inv2][2],object_mpcost)) then
          	  useitem_packet_write(
          	    client,
          	    client_list[client][client_stats][stat_inv2][2],
          	    real(object_delta(  client_list[client][client_stats][stat_inv2][2], object_slotType)) )
            end if
          end if
        end if
      end if


      client_list[client][client_stats]=stats
    end if

  end for --i

  if equal(map_name,"Nexus")=1 and mystats[2][2]!=mystats[1][2] and level_20_reached=0 then --move to fountines into health is fully recovered

    	
      client_list[client][client_tx]=68
      client_list[client][client_ty]=70
  elsif equal(map_name,"Nexus")=1 then --move to relam portal area

    if level_20_reached=1 or mystats[2][2]=mystats[1][2] then
      client_list[client][client_tx]=70
      client_list[client][client_ty]=45
      if point_distance(client_list[client][client_x],client_list[client][client_y],client_list[client][client_tx],client_list[client][client_ty])<0.5 then
        find_portal(client,70,45)
      end if
    end if
  	
  elsif equal(map_name,"Nexus")=0 and loot_bag_found=0 then
  	--pathfinding set the target x and y
  	--check the bot as reached the traget x and y and set new target
  	--need to build a walkable map including solid objects
  	
  	if point_distance(client_list[client][client_x],client_list[client][client_y],client_list[client][client_tx],client_list[client][client_ty])<0.5 then
  	

      --else
        if level_20_reached=1 and enemy_near(client,client_list[client][client_x],client_list[client][client_y])>=20 then
          client_list[1][client_tx]=client_list[client][client_x]
          client_list[1][client_ty]=client_list[client][client_y]
        elsif questobjid!=0 then
      	  object_handle=hash_get_handle(client_list[client][client_hash],hash_index(questobjid),questobjid)
      	  x=object_get_x(client_list[client][client_objectlist],object_handle)
  	      y=object_get_y(client_list[client][client_objectlist],object_handle)
  	      if level_20_reached=0 then
  	       client_list[1][client_tx]=x+1
            client_list[1][client_ty]=y+1
	      else
	        client_list[1][client_tx]=x
            client_list[1][client_ty]=y
  	      end if
        else
	      angle=rand(360)
          client_list[1][client_tx]+=10*sin(degtorad(angle))
          client_list[1][client_ty]-=10*cos(degtorad(angle))
        end if
      --end if
    else --point_direction

      object_handle=enemy_closest2(client,client_list[client][client_x],client_list[client][client_y] )
      if object_handle!=0 then

        x=object_get_x(client_list[client][client_objectlist],object_handle)
  	    y=object_get_y(client_list[client][client_objectlist],object_handle)
  	    if level_20_reached=0 then
  	      client_list[1][client_tx]=x+1
          client_list[1][client_ty]=y+1
	    else
	      client_list[1][client_tx]=x
          client_list[1][client_ty]=y
  	    end if
  	  end if
  	
    end if
  end if

  --if lastrealmportal!=0 and equal(map_name,"Nexus")=1 and targetinnexus=0 and mystats[2][2]=mystats[1][2] then
  --  useportal_packet_write(client, lastrealmportal)
  --end if


    if loot_bag_found=1 then

    if point_distance(client_list[client][client_x],client_list[client][client_y],client_list[client][client_tx],client_list[client][client_ty])<0.5 then
      object_handle=hash_get_handle(client_list[client][client_hash],hash_index(loot_bag_id),loot_bag_id)
	  if object_handle!=0 then
      stats=object_get_stats(client_list[client][client_objectlist],object_handle)
      mystats=client_list[client][client_stats]

      slottypes=player_slottypes(object_delta(client_list[client][client_object_type],object_slotTypes))
      for k=1 to 4 do
      	--?mystats[8+k]
      end for
      --standing at the location of the loot bag
      for j=9 to 9+7 do
        if stats[j][2]!=-1 then
      	  slottype=real(object_delta(stats[j][2],object_slotType))
          for k=1 to 4 do
            if slottype=slottypes[k] then
              --puts(1,"item found "&sprint(slottype)&"\n")
              --need to check tire
              if mystats[8+k][2]=-1 then

              	inv_swap(mystats[8+k], stats[j], client_list[client][client_object_id], loot_bag_id, client_list[client][client_x],client_list[client][client_y],  client)
                loot_bag_found=0
                exit	

              else
                if sequence(object_delta(mystats[8+k][2],object_tier)) and sequence(object_delta(stats[j][2],object_tier))  then
                  tier1= real(object_delta(mystats[8+k][2],object_tier))
                  tier2= real(object_delta(stats[j][2],object_tier))
                  --puts(1,"tire1: "&sprint(tier1)&"\n" )
                  --puts(1,"tire2: "&sprint(tier2)&"\n" )
                  if tier2>tier1 then

                    inv_swap(mystats[8+k], stats[j], client_list[client][client_object_id], loot_bag_id, client_list[client][client_x],client_list[client][client_y],  client)
                    loot_bag_found=0
                    exit		

                  end if
                end if
              end if

            end if
          end for
          if loot_bag_found=0 then
          	exit
          end if
        end if

      end for

      end if
    end if
  end if


  write=""
  write=writeint(write,tick_id) --tick id
  ttime=current_time()

  current_angle=get_angle_to(client_list[1][client_x],client_list[1][client_y],client_list[1][client_tx],client_list[1][client_ty])

  client_list[client][client_last_move_time]=ttime

  write=writeint(write,ttime) --time

  --position

  write=writefloat(write,client_list[client][client_x])
  write=writefloat(write,client_list[client][client_y])

  write=writeshort(write,0)


  temp=reverse(int_to_bytes(length(write)+5)) &move_packet
  write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
  socket_send_data(client,temp&write)





end procedure
packet_read_id[new_tick_packet+1]=routine_id("new_tick_packet_read")

procedure goto_packet_read(integer client,integer inputstream)
  object res,x,y
  sequence write,temp

  res=input_stream_readint(inputstream)
  x=input_stream_readfloat(inputstream)
  y=input_stream_readfloat(inputstream)

  if res=client_list[client][client_object_id] then
  	client_list[client][client_x]=x
  	client_list[client][client_y]=y
  	client_list[client][client_tx]=x
  	client_list[client][client_ty]=y
  end if

  write=""
  write=writeint(write,current_time()) --time

  temp=reverse(int_to_bytes(length(write)+5)) &gotoack_packet
  write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
  socket_send_data(client,temp&write)
end procedure

packet_read_id[goto_packet+1]=routine_id("goto_packet_read")

procedure nameresult_packet_read(integer client,integer inputstream)
  object res
  integer bool
  bool=input_stream_readbyte(inputstream)

  res=input_stream_readutf(inputstream)

  if match("Error.notEnoughGold",res) then
  	client_list[client][client_isnamed]=1 --hack 16.5
  end if
  if bool=0 then

  else
    client_list[client][client_isnamed]=1
  end if

end procedure
packet_read_id[nameresult_packet+1]=routine_id("nameresult_packet_read")


procedure connect_to_portal(sequence hostip )
  integer iwork, port
  atom Server_sock
  sequence swork,ip

  port = 2050

  Server_sock=Wsock_new(hostip, 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))  --eu west 2

end procedure

sequence list_of_reconnect_clients
list_of_reconnect_clients={}

procedure reconnect_client_add(integer client)
  	list_of_reconnect_clients=append(list_of_reconnect_clients,{client, current_time()+1000})
end procedure


sequence last_hostip
last_hostip=""
procedure reconnect_packet_read(integer client,integer inputstream)
  atom game_id,key_size,key_time
  sequence key,hostip
  object res
  integer size
  res=input_stream_readutf(inputstream)
  --puts(1,"name "&res&"\n")
  res=input_stream_readutf(inputstream)
  --puts(1,"host "&res&"\n")
  if length(res) then
  	hostip=res
  	last_hostip=res
  else
    hostip=last_hostip
  end if

  res=input_stream_readint(inputstream)
  --puts(1,"port\n")
  --?res

  game_id=input_stream_readint(inputstream)

  key_time=input_stream_readint(inputstream)

  res=input_stream_readbyte(inputstream) --is from arena

  key_size=input_stream_readshort(inputstream)

  key=input_stream_readfully(inputstream,key_size)

  --?key
  --puts(1,key&"\n")
  --?key_time
  --?key_size

  client_list[client][client_reconnect]={game_id,key_size,key_time,key,hostip}
  --?client_list[client][client_reconnect]

  sockets[client_list[client][client_socket]]=0

  WsockCloseSocket(client_list[client][client_socket])

  client_init(client)

  reconnect_client_add(client)


end procedure

packet_read_id[reconnect_packet+1]=routine_id("reconnect_packet_read")

procedure read_packet(integer client)
  sequence data,fail_message
  integer inputstream,packet_id,packet_len
  object ret


  inputstream=client_list[client][client_inputstream]

  while 1 do

  if client_list[client][client_socket]=0 then --new hacking thinking
    exit
  end if
  if sockets[client_list[client][client_socket]]=0 then --new bug fix send data
    --puts(1,"slowing down send packets\n")
  	exit
  end if

  if input_stream_length(inputstream)>=5 and input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
  else
    exit
  end if

  packet_id=input_stream_peek(inputstream,5)
  packet_len=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} )
	
  --puts(1,packet_names[packet_id+1]&"\n")

  if input_stream_length(inputstream)>=5 then
  	data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_1],input_stream_slice(inputstream,6,packet_len))
  	
  	input_stream_set(inputstream, input_stream_slice(inputstream,packet_len+1, input_stream_length(inputstream) ) )

  	input_stream_set(inputstream, data&input_stream_get(inputstream))	
  	
  end if

  if packet_id=fail_packet then
    puts(1,"fail ")
  	?input_stream_readint(inputstream)
  	fail_message=input_stream_readutf(inputstream)
  	puts(1,fail_message&"\n")
    WsockCloseSocket(client_list[client][client_socket])
  	if length(fail_message)>6 then
  	  if match("Account already has 1 active characters",fail_message) then --hack 16.5
  	  	client_list[client][client_created]=1
  	  elsif match(lower("Incorrect Portal key"),lower(fail_message))  then
  	    client_list[client][client_reconnect]={-2,0,-1,{},""}
  	    lastrealmportal=lastnexusportal
  	    connect_to_server()
  	  elsif match(lower("Lost connection to server"),lower(fail_message))  then
  	
  	    connect_to_server()
  	    --puts(1,"gaz debug\n")
  	  elsif fail_message[1]='A' and fail_message[2]='c' then
  	    puts(1,"client id: "&sprint(client)&"\n")
  	    client_list[client][client_acountinuse]=1  	
  	  end if	
  	end if
  	
  	input_stream_set(inputstream, "")
  	client_set_connected(client,0)
  	sockets[client_list[client][client_socket]]=0
    WsockCloseSocket(client_list[client][client_socket])
  	
  	
  	exit
  end if

  if packet_read_id[packet_id+1]!=-1 then


    client_set_packet_len(client,packet_len)--new fix mapload packet

    call_proc(packet_read_id[packet_id+1], {client,inputstream})	

  else
   puts(1,"read unknow packet with id:"&sprint(packet_id)&"\n")
   WsockCloseSocket(client_list[client][client_socket])
   input_stream_set(inputstream, "")
   sleep(100)
   ?1/0
   exit
  end if

  end while
end procedure


procedure processServerMessage(atom hWnd, atom arg1, atom arg2)
  atom      index, newsock
  integer   action, sock, iwork,inputstream,client_index
  object    owork,junk,found
  sequence  newIP,swork,rx,tx
  sequence  data

  action = lo_word(arg2)
  sock = arg1

  if action=FD_CONNECT then
  	puts(1,"Server Connected\n")

    newIP = WsockGetSockName(sock)
    last_hostip=newIP
  	--sockets[sock]=client_not_connected_ip(newIP)
  	sockets[sock]=client_not_connected()

  	if sockets[sock]!=0  then--send the hello packet with the settings from the client
  	
      client_init(sockets[sock]) --new 13/03/2014
  	  client_set_socket(sockets[sock],sock)
  	  client_set_connected(sockets[sock],1)
  	
  	  loot_bag_found=0
      loot_bag_id=0
      started_time=0
      questobjid=0
  	

  	  socket_send_data(sockets[sock],hello_packet_write(sockets[sock],client_list[sockets[sock]][client_email],client_list[sockets[sock]][client_pass]))

      if sockets[sock]!=0 then--bug fix send _data can close the socket
        --client_list[sockets[sock]][client_reconnect]={-2,0,-1,{},""}
        if client_is_created(sockets[sock])=1 then
          socket_send_data(sockets[sock],load_packet_write(sockets[sock],client_list[sockets[sock]][client_char_id]))
        else
	      socket_send_data(sockets[sock],create_packet_write(sockets[sock]))
        end if

      end if

  	else
  	  WsockCloseSocket(sock)
  	end if
  	

  elsif action = FD_READ then
    if sockets[sock]=0 then
      return 	
    end if

    rx = ""
    owork = WsockReadData_1024(sock,1024)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData_1024(sock,1024)
    end while
    if owork=-9999 then
      client_set_connected(sockets[sock],0)
      client_init(sockets[sock])	
      return
    end if

    if length(rx) > 0 then

      inputstream=client_list[sockets[sock]][client_inputstream]

      input_stream_append(inputstream,rx)

      if input_stream_length(inputstream)>=5 then

        if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          read_packet(sockets[sock])	
        end if
      end if

    end if
  elsif action = FD_CLOSE then
     puts(1,"server closed\n")
     WsockCloseSocket(sock)



     if sockets[sock]!=0 then --bug fix, send packet
       puts(1,"method 1\n")
       --if client_list[sockets[sock]][client_state]!=1 then--new hacking thinking

       client_set_connected(sockets[sock],0)
       client_init(sockets[sock])
       connect_to_server()

       --puts(1,"connected count: ("&sprint(client_connected_count())&")\n" )
       --puts(1,"account in use count: ("&sprint(client_accountinuse_count())&")\n" )
       --end if
     else
       puts(1,"method 2\n")
       client_index=client_from_socket(sock)

       if client_index!=0 then
         if client_list[client_index][client_state]!=1 then--new hacking thinking
       	 ?client_index
       	 client_set_connected(client_index,0)
       	 client_init(client_index)
       	 connect_to_server()
       	
       	 --puts(1,  "connected count: ("&sprint(client_connected_count())&")\n" )
       	 --puts(1,"account in use count: ("&sprint(client_accountinuse_count())&")\n" )
       	 end if
       else
         puts(1,"um not sure weired\n")
       end if
     end if

     sockets[sock]=0
  end if
end procedure

--54.241.208.233 us west
--54.195.154.140 euwest 2
--?client_new(create_random_guild(), "", "54.195.154.140", 0, 1, 782 )
--client_list[length(client_list)][client_created]=0
--connect_to_server()

atom fps,frame
fps=0
frame=0
setTimer(Window1,1000,30)
setTimer(Window1,1001,1000)

setTimer(Window1,1002,1000*3)


-------------------------------------web code to create a new account----------------------------------------------


function class_name_to_id(sequence name)

	if equal(name,"Rogue") then
	  return 768	
	elsif equal(name,"Archer") then
	  return 775
	elsif equal(name,"Wizard") then
	  return 782
	elsif equal(name,"Priest") then
	  return 784
	elsif equal(name,"Warrior") then
	  return 797
	
    --new 1-12-2013
    elsif equal(name,"Knight") then
	  return 798
	elsif equal(name,"Paladin") then
	  return 799
	elsif equal(name,"Assassin") then
	  return 800
	elsif equal(name,"Necromancer") then
	  return 801
	elsif equal(name,"Huntress") then
	  return 802
	elsif equal(name,"Mystic") then
	  return 803
	elsif equal(name,"Trickster") then
	  return 804
	elsif equal(name,"Sorcerer") then
	  return 805
	elsif equal(name,"Ninja") then
	  return 806
	end if
end function

function find_best_class(sequence class)
--unlock oder
--Wizard
--Priest
--Archer
--Rogue
--Warrior
--798 Knight
--799 Paladin
--800 Assassin
--801 Necromancer
--802 Huntress
--803 Mystic
--804 Trickster
--805 Sorcerer
--806 Ninja

  if length(class)=0 then
  	return class_name_to_id("Wizard")
  end if

  if find(class_name_to_id("Ninja"),class)!=0 then
  	return class_name_to_id("Ninja")
  end if

  if find(class_name_to_id("Sorcerer"),class)!=0 then
  	return class_name_to_id("Ninja")
  end if

  if find(class_name_to_id("Trickster"),class)!=0 then
  	return class_name_to_id("Sorcerer")
  end if

  if find(class_name_to_id("Mystic"),class)!=0 then
  	return class_name_to_id("Trickster")
  end if

  if find(class_name_to_id("Huntress"),class)!=0 then
  	return class_name_to_id("Mystic")
  end if

  if find(class_name_to_id("Necromancer"),class)!=0 then
  	return class_name_to_id("Huntress")
  end if

  if find(class_name_to_id("Assassin"),class)!=0 then
  	return class_name_to_id("Necromancer")
  end if

  if find(class_name_to_id("Paladin"),class)!=0 then
  	return class_name_to_id("Assassin")
  end if

  if find(class_name_to_id("Knight"),class)!=0 then
  	return class_name_to_id("Paladin")
  end if

  if find(class_name_to_id("Warrior"),class)!=0 then
  	return class_name_to_id("Knight")
  end if

  if find(class_name_to_id("Rogue"),class)!=0 then
  	return class_name_to_id("Warrior")
  end if

  if find(class_name_to_id("Archer"),class)!=0 then
  	return class_name_to_id("Rogue")
  end if

  if find(class_name_to_id("Priest"),class)!=0 then
  	return class_name_to_id("Archer")
  end if

  if find(class_name_to_id("Wizard"),class)!=0 then
  	return class_name_to_id("Priest")
  end if

end function

function check_best_class(integer class)
 sequence maxclass_list,bestclass
 integer cs,level
 maxclass_list=account_get_maxclass()
 bestclass={}
 if length(maxclass_list) then
   for i=1 to length(maxclass_list) do
   	 cs=real(maxclass_list[i][1][2])
   	 level=real(maxclass_list[i][2][2])
   	 if level=20 then
   	   bestclass&=cs
   	 end if
   end for
 end if

	if class=class_name_to_id("Wizard") then
	
	   return class	
	
	elsif class=class_name_to_id("Priest") then
	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    return class
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	
 	elsif class=class_name_to_id("Archer") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	       return class
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	
 	elsif class=class_name_to_id("Rogue") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        return class
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	
    elsif class=class_name_to_id("Warrior") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          return class
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	
   elsif class=class_name_to_id("Knight") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	             return class
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	
   elsif class=class_name_to_id("Paladin") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              return class
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
    elsif class=class_name_to_id("Assassin") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                return class
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
   elsif class=class_name_to_id("Necromancer") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                if find(class_name_to_id("Assassin"),bestclass) then
	                  return class
	                else
	                  return class_name_to_id("Assassin")
	                end if
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if 	
  elsif class=class_name_to_id("Huntress") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                if find(class_name_to_id("Assassin"),bestclass) then
	                  if find(class_name_to_id("Necromancer"),bestclass) then
	                    return class
	                  else
	                    return class_name_to_id("Necromancer")
                      end if
	                else
	                  return class_name_to_id("Assassin")
	                end if
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	elsif class=class_name_to_id("Mystic") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                if find(class_name_to_id("Assassin"),bestclass) then
	                  if find(class_name_to_id("Necromancer"),bestclass) then
	                    if find(class_name_to_id("Huntress"),bestclass) then
	                      return class
	                    else
	                      return class_name_to_id("Huntress")
                        end if
	                  else
	                    return class_name_to_id("Necromancer")
                      end if
	                else
	                  return class_name_to_id("Assassin")
	                end if
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	
  	elsif class=class_name_to_id("Trickster") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                if find(class_name_to_id("Assassin"),bestclass) then
	                  if find(class_name_to_id("Necromancer"),bestclass) then
	                    if find(class_name_to_id("Huntress"),bestclass) then
	                      if find(class_name_to_id("Mystic"),bestclass) then
	                        return class
	                      else
	                        return class_name_to_id("Mystic")
                          end if
	                    else
	                      return class_name_to_id("Huntress")
                        end if
	                  else
	                    return class_name_to_id("Necromancer")
                      end if
	                else
	                  return class_name_to_id("Assassin")
	                end if
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	elsif class=class_name_to_id("Sorcerer") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                if find(class_name_to_id("Assassin"),bestclass) then
	                  if find(class_name_to_id("Necromancer"),bestclass) then
	                    if find(class_name_to_id("Huntress"),bestclass) then
	                      if find(class_name_to_id("Mystic"),bestclass) then
	                        if find(class_name_to_id("Trickster"),bestclass) then
	                          return class
	                        else
	                          return class_name_to_id("Trickster")
                            end if
	                      else
	                        return class_name_to_id("Mystic")
                          end if
	                    else
	                      return class_name_to_id("Huntress")
                        end if
	                  else
	                    return class_name_to_id("Necromancer")
                      end if
	                else
	                  return class_name_to_id("Assassin")
	                end if
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
 	elsif class=class_name_to_id("Ninja") then
 	
	  if find(class_name_to_id("Wizard"),bestclass) then
	    if find(class_name_to_id("Priest"),bestclass) then
	      if find(class_name_to_id("Archer"),bestclass) then
	        if find(class_name_to_id("Rogue"),bestclass) then
	          if find(class_name_to_id("Warrior"),bestclass) then
	            if find(class_name_to_id("Knight"),bestclass) then
	              if find(class_name_to_id("Paladin"),bestclass) then
	                if find(class_name_to_id("Assassin"),bestclass) then
	                  if find(class_name_to_id("Necromancer"),bestclass) then
	                    if find(class_name_to_id("Huntress"),bestclass) then
	                      if find(class_name_to_id("Mystic"),bestclass) then
	                        if find(class_name_to_id("Trickster"),bestclass) then
	                          if find(class_name_to_id("Sorcerer"),bestclass) then
	                            return class
	                          else
	                            return class_name_to_id("Sorcerer")
                              end if
	                        else
	                          return class_name_to_id("Trickster")
                            end if
	                      else
	                        return class_name_to_id("Mystic")
                          end if
	                    else
	                      return class_name_to_id("Huntress")
                        end if
	                  else
	                    return class_name_to_id("Necromancer")
                      end if
	                else
	                  return class_name_to_id("Assassin")
	                end if
	              else
	                return class_name_to_id("Paladin")
                  end if
	            else
	              return class_name_to_id("Knight")
                end if
	          else
	             return class_name_to_id("Warrior")
              end if
	        else
	          return class_name_to_id("Rogue")
            end if
	      else
	        return class_name_to_id("Archer")
          end if
	    else
	      return class_name_to_id("Priest")
	    end if
	  else
        return class_name_to_id("Wizard")		
 	  end if
	end if
end function

function find_best_class_to_unlock_trickster(sequence class)
--unlock oder
--782 Wizard
--784Priest
--775Archer
--768Rogue
--797Warrior
--798 Knight
--799 Paladin
--800 Assassin
--801 Necromancer
--802 Huntress
--803 Mystic
--804 Trickster
--805 Sorcerer
--806 Ninja

  if length(class)=0 then
  	return class_name_to_id("Wizard")
  end if

  if find(class_name_to_id("Trickster"),class)!=0 then
  	return class_name_to_id("Trickster")
  end if

  if find(class_name_to_id("Assassin"),class)!=0 then
  	return class_name_to_id("Trickster")
  end if

  if find(class_name_to_id("Paladin"),class)!=0 then
  	return class_name_to_id("Assassin")
  end if

  if find(class_name_to_id("Knight"),class)!=0 then
  	return class_name_to_id("Paladin")
  end if

  if find(class_name_to_id("Warrior"),class)!=0 then
  	return class_name_to_id("Knight")
  end if

  if find(class_name_to_id("Rogue"),class)!=0 then
  	return class_name_to_id("Warrior")
  end if

  if find(class_name_to_id("Archer"),class)!=0 then
  	return class_name_to_id("Rogue")
  end if

  if find(class_name_to_id("Priest"),class)!=0 then
  	return class_name_to_id("Archer")
  end if

  if find(class_name_to_id("Wizard"),class)!=0 then
  	return class_name_to_id("Priest")
  end if

end function




function class_select()
--unlock oder
--Wizard
--Priest
--Archer
--Rogue
--Warrior
--798 Knight
--799 Paladin
--800 Assassin
--801 Necromancer
--802 Huntress
--803 Mystic
--804 Trickster
--805 Sorcerer
--806 Ninja
 sequence maxclass_list,bestclass
 integer class,level
 maxclass_list=account_get_maxclass()
 bestclass={}
 if length(maxclass_list) then
   for i=1 to length(maxclass_list) do
   	 class=real(maxclass_list[i][1][2])
   	 level=real(maxclass_list[i][2][2])
   	 if level=20 then
   	   bestclass&=class
   	 end if
   end for
   --?find_best_class(bestclass)
   return find_best_class(bestclass)
   --return find_best_class_to_unlock_trickster(bestclass)
 else
   return class_name_to_id("Wizard")
 end if
end function





global constant SM_ASYNC2 = #FFFD
atom webserver_sock
webserver_sock=0
sequence getbuffer
getbuffer={}


procedure connect_to_webserver()
  integer port
  atom ret
  port = 80
  --webserver_sock=Wsock_new("realmofthemadgod.appspot.com", port , hWndMainWindow, SM_ASYNC2,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  webserver_sock=Wsock_new("173.194.66.141", port , hWndMainWindow, SM_ASYNC2,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

  ?webserver_sock
  if webserver_sock=-1 then
  	ret = message_box("Unable to connect to realmofthemadgod.appspot.com on port 80","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
    return
  end if
end procedure


function http_respond2(sequence data)
sequence sh	
sh ="" -- Server header
    -- Server return header
    sh &= "POST /char/list HTTP/1.1\n"
    sh &= "Host: realmofthemadgod.appspot.com\n"
    sh &= "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0\n"
    sh &= "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
    sh &= "Accept-Language: en-gb,en;q=0.5\n"
    --sh &= "Accept-Encoding: gzip, deflate\n"
    sh &= "Connection: keep-alive\n"
    sh &= "Content-Type: application/x-www-form-urlencoded\n"
    sh &= sprintf("Content-Length: %d\n",{length(data)})

    return sh & 13 & 10 & data
end function

function email_replace(sequence email)
sequence temp
  temp={}
  for i=1 to length(email) do
	if email[i]='+' then
	  temp&="%2B"
	else
	  temp&=email[i]
	end if	
  end for
  return temp
end function


procedure processWebServerMessage(atom hWnd, atom arg1, atom arg2)
  atom      index, newsock
  integer   action, sock, iwork,pos
  object    owork,junk,ret
  sequence  newIP,swork,rx,tx
  sequence  data,temp
  integer fn,content_length


  action = lo_word(arg2)
  sock = arg1

  if action=FD_CONNECT then

     getbuffer={}

     iwork=WsockSendData(webserver_sock,http_respond2("guid="&email_replace(getText(textbox_email))&"&ignore=6373&password="&getText(textbox_password)))

     ?234
  elsif action = FD_READ then
    rx = ""
    owork = WsockReadData(sock,1)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData(sock,1)
    end while

    if length(rx) > 0 then
      getbuffer&=rx

      --puts(1,rx&"\n\n\n\n")
      --?rx
      --?123456
      pos=match("<Error>Account credentials not valid</Error>",getbuffer)
      if pos!=0 then

       	ret = message_box("Account credentials not valid","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
       	return
      end if

      pos=match("Content-Length",getbuffer)
      if pos!=0 then
        --puts(1,getbuffer[pos+16..pos+16+10])
        for i=pos+16 to pos+16+10 do
          if getbuffer[i]>='0' and getbuffer[i]<='9' then
          else
            --puts(1,"content length\n")
      	    --puts(1,getbuffer[pos+16..i-1])
      	    --?getbuffer[pos+16..i-1]
      	    content_length=real(getbuffer[pos+16..i-1])
      	    --?pos
      	    exit
      	  end if
      	end for
      end if
      --puts(1,"length getbuffer\n")
      --?length(getbuffer)

      if length(getbuffer)>content_length then
      --if equal(getbuffer[length(getbuffer)-3..length(getbuffer)],{13,10,13,10}) then

       --?4567
       pos=match("<Chars",getbuffer)


       fn=open("xml\\account.xml","w")
       for i=pos to length(getbuffer) do
       	puts(fn,getbuffer[i])
       end for
       close(fn)

       pos=0
       pos=match("<Error>Account in use ",getbuffer)
       if pos!=0 then

       	--ret = message_box("Account in use","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
       	puts(1,getbuffer[pos..length(getbuffer)])
       	--puts(1,"Account in use\n")
       	sleep(3)
       	?1/0
       	return
       end if
       ret=xml_account_load()
       ret=account_get_chars()
       if length(ret) then --has chars
         --54.241.208.233 us west
         --54.195.154.140 euwest 2
         --puts(1,"testng gaz \n")
         --?real(char_delta(1,char_id))
         --client_new(sequence email, sequence pass, sequence serverip, integer sock, integer char_id, integer cobjtype )
         --puts(1,"type "&sprint(real(char_delta(1,char_object_type)))&"\n")
         ?client_new(getText(textbox_email), getText(textbox_password), server_list[getIndex(combox_serverlist)][2], 0, real(char_delta(1,char_id)), real(char_delta(1,char_object_type)) )
         client_list[length(client_list)][client_created]=1
         connect_to_server()
       else
         ?client_new(getText(textbox_email), getText(textbox_password), server_list[getIndex(combox_serverlist)][2], 0, real(account_nextcharid()), check_best_class(class_select()) )
         client_list[length(client_list)][client_created]=0
         connect_to_server()	
       end if

      end if

    end if
  elsif action = FD_CLOSE then
     WsockCloseSocket(sock)
  end if
end procedure


--connect_to_webserver()


#EndProc

#Proc: onEvent
procedure Window1_onEvent (integer self, integer event, sequence params)--params is ( int iMsg, atom wParm, atom lParm )
  if params[1] = SM_ASYNC then
	processServerMessage(hWndMainWindow,params[2],params[3])
  elsif params[1] = SM_ASYNC2 then
  	processWebServerMessage(hWndMainWindow,params[2],params[3])
  end if
end procedure
setHandler( Window1, w32HEvent, routine_id("Window1_onEvent"))
#EndProc

#Proc: onOpen
procedure Window1_onOpen (integer self, integer event, sequence params)--params is ()
  if isChecked(checkbox_auto_connect)=1 then
  	con_email=getText(textbox_email)
    con_pass=getText(textbox_password)
    con_owner=getText(textbox_owner)
    connect_to_webserver()
  end if
end procedure
setHandler( Window1, w32HOpen, routine_id("Window1_onOpen"))
#EndProc

#Proc: onTimer
procedure Window1_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
atom angle,SPEED,object_handle,x,y,client
sequence list
  if params[1]=1000 then

     for j=1 to length(list_of_reconnect_clients) do --get them all

    for i=1 to length(list_of_reconnect_clients) do
      if list_of_reconnect_clients[i][2]<current_time() then

        client_init(list_of_reconnect_clients[i][1])

        connect_to_portal(client_list[ list_of_reconnect_clients[i][1] ] [ client_reconnect][5] )

        client_set_connected(list_of_reconnect_clients[i][1],0)
        list_of_reconnect_clients=remove_line(list_of_reconnect_clients,i)
	  exit
    end if
    end for

    end for

    if length(client_list) and length(client_list[1][client_stats]) and client_list[1][client_first_update]=1 then

    if started_time=0 then
      start_time=current_time()
      started_time=1
      point_x=client_list[1][client_x]
      point_y=client_list[1][client_y]
      current_angle=get_angle_to(client_list[1][client_x],client_list[1][client_y],client_list[1][client_tx],client_list[1][client_ty])
    end if

    SPEED=speed()--/1.1--(0.004 + ( ( (client_list[1][client_stats][stat_speed][2]-2) / 75) * (0.0096 - 0.004)))
    --?SPEED/1.1
    elasped_time = current_time()-start_time

    total_move_time+=elasped_time

    --if elasped_time>30 then
    --  elasped_time=30	
    --end if

    angle=get_angle_to(client_list[1][client_x],client_list[1][client_y],client_list[1][client_tx],client_list[1][client_ty])

    --if angle!=current_angle then
    --if tx!=client_list[1][client_tx] or ty!=client_list[1][client_ty] then
    	
      --enter_world(current_time(),client_list[1][client_x],client_list[1][client_y])
      --current_angle=angle	
      tx=client_list[1][client_tx]
      ty=client_list[1][client_ty]
      --?client_list[1][client_x]
      --?client_list[1][client_y]
    --end if

    if point_distance(client_list[1][client_x],client_list[1][client_y],client_list[1][client_tx],client_list[1][client_ty])<0.5 then
      client_list[1][client_x]=client_list[1][client_tx]
      client_list[1][client_y]=client_list[1][client_ty]
    else
      --client_list[1][client_x]+=(elasped_time * SPEED)*sin(degtorad(angle))
      --client_list[1][client_y]-=(elasped_time * SPEED)*cos(degtorad(angle))
      client_list[1][client_x]+=(elasped_time * SPEED)*sin(degtorad(current_angle))
      client_list[1][client_y]-=(elasped_time * SPEED)*cos(degtorad(current_angle))
    end if

    --?current_angle

    speed_ground()
    --projectile_update()
    projectile_update_new()
    --projectile_enemy_update_new()

    client=1
    object_handle=enemy_closest(client, client_list[client][client_x], client_list[client][client_y])
  --?object_handle
  if object_handle!=0 and level_20_reached=0 and equal(map_name,"Nexus")=0 then
  	if client_list[client][client_stats][9][2]!=-1 then --equipment slot 1 not empty
  	  x=object_get_x(client_list[client][client_objectlist],object_handle)
  	  y=object_get_y(client_list[client][client_objectlist],object_handle)
      playershoot_packet_write(client, client_list[client][client_stats][stat_inv1][2],  toRotmgAngle(get_angle_to(client_list[client][client_x],client_list[client][client_y],x,y)))
    end if
  end if

    end if

    start_time=current_time()

    frame+=1

  elsif params[1]=1001 then
    fps=frame
  	frame=0	
  	--puts(1,"fps: "&sprint(fps)&"\n")
  elsif params[1]=1002  then
  	 list={}


   for i=1 to length(client_list) do
    if client_list[i][client_acountinuse]=1 then
      list&=i
	end if
  end for


  if length(list) then
  	client_list[ list[rand(length(list))] ][client_acountinuse]=0
  end if

  if client_connected_count()<1 then
  	connect_to_server()
  end if

  --hack because closing of the connection detection is still failling somewhere
  for i=1 to length(client_list) do
    if client_list[i][client_is_connected]=1 then

      if client_list[i][client_last_move_time]=0 then
      	client_list[i][client_last_move_time]=current_time()
      end if

	  if client_list[i][client_last_move_time]<current_time()-(1000*30) then --15 seconds
	
	  	client_list[i][client_is_connected]=0
	  	client_init(i)
	    puts(1,"in time event 1002 haahaha :"&sprint(i)&"\n")
	  end if
	
	end if
  end for
	
  --puts(1,"connected count: ("&sprint(client_connected_count())&")\n" )
  --puts(1,"account in use count: ("&sprint(client_accountinuse_count())&")\n" )
  end if
end procedure
setHandler( Window1, w32HTimer, routine_id("Window1_onTimer"))
#EndProc

#Control: LText8
AWindow : 30
X       : 10
Y       : 10
CX      : 60
CY      : 20
ControlLayer: 0
Title   : Server:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 6
Local : 1
OrigTitle : LText8

#Control: combox_serverlist
AWindow : 30
X       : 70
Y       : 10
CX      : 150
CY      : 20
ControlLayer: 0
Title   : 
Class   : Combo
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 1
Local : 1
OrigTitle : Combo7

#Control: LText19
AWindow : 30
X       : 380
Y       : 20
CX      : 70
CY      : 20
ControlLayer: 0
Title   : Build version
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 3
Local : 1
OrigTitle : LText19

#Control: EditText20
AWindow : 30
X       : 450
Y       : 20
CX      : 90
CY      : 20
ControlLayer: 0
Title   : 19.5.1
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 5
Local : 1
OrigTitle : EditText20

#Control: LText9
AWindow : 30
X       : 10
Y       : 40
CX      : 60
CY      : 20
ControlLayer: 0
Title   : Email:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 8
Local : 1
OrigTitle : LText9

#Control: textbox_email
AWindow : 30
X       : 70
Y       : 40
CX      : 110
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 10
Local : 1
OrigTitle : EditText10

#Control: checkbox_auto_connect
AWindow : 30
X       : 210
Y       : 40
CX      : 150
CY      : 20
ControlLayer: 0
Title   : Auto connect on startup
Class   : CheckBox
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 18
Local : 1
OrigTitle : CheckBox18

#Control: LText21
AWindow : 30
X       : 370
Y       : 50
CX      : 80
CY      : 20
ControlLayer: 0
Title   : Immediate int1:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 7
Local : 1
OrigTitle : LText21

#Control: Immediate_int1
AWindow : 30
X       : 450
Y       : 50
CX      : 90
CY      : 20
ControlLayer: 0
Title   : 20934212
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 9
Local : 1
OrigTitle : EditText22

#Control: LText11
AWindow : 30
X       : 10
Y       : 70
CX      : 60
CY      : 20
ControlLayer: 0
Title   : Password:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 12
Local : 1
OrigTitle : LText11

#Control: textbox_password
AWindow : 30
X       : 70
Y       : 70
CX      : 110
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 13
Local : 1
OrigTitle : EditText12

#Control: checkbox_suicide
AWindow : 30
X       : 210
Y       : 70
CX      : 150
CY      : 20
ControlLayer: 0
Title   : Suicide at level 20 
Class   : CheckBox
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 2
Local : 1
OrigTitle : CheckBox25

#Control: LText23
AWindow : 30
X       : 370
Y       : 80
CX      : 80
CY      : 20
ControlLayer: 0
Title   : Immediate int2:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 11
Local : 1
OrigTitle : LText23

#Control: Immediate_int2
AWindow : 30
X       : 450
Y       : 80
CX      : 90
CY      : 20
ControlLayer: 0
Title   : 34329
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 19
Local : 1
OrigTitle : EditText24

#Control: LText15
AWindow : 30
X       : 440
Y       : 110
CX      : 80
CY      : 20
ControlLayer: 0
Title   : Target player:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 4
Local : 1
OrigTitle : LText15

#Control: PushButton13
AWindow : 30
X       : 10
Y       : 140
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Connect
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 14
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton13

#Proc: onClick
procedure PushButton13_onClick (integer self, integer event, sequence params)--params is ()
  con_email=getText(textbox_email)
  con_pass=getText(textbox_password)
  con_owner=getText(textbox_owner)
  connect_to_webserver()
end procedure
setHandler( PushButton13, w32HClick, routine_id("PushButton13_onClick"))
#EndProc

#Control: PushButton14
AWindow : 30
X       : 110
Y       : 140
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Save
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 15
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton14

#Proc: onClick
procedure PushButton14_onClick (integer self, integer event, sequence params)--params is ()
integer fn
fn=open("config.txt","w")
puts(fn,getText(textbox_email)&"\n")
puts(fn,getText(textbox_password)&"\n")
puts(fn,getText(textbox_owner)&"\n")
puts(fn,sprint(getIndex(combox_serverlist)) &"\n")
puts(fn,sprint(isChecked(checkbox_auto_connect)) &"\n")
puts(fn,sprint(isChecked(checkbox_suicide)) &"\n")
close(fn)
end procedure
setHandler( PushButton14, w32HClick, routine_id("PushButton14_onClick"))
#EndProc

#Control: textbox_owner
AWindow : 30
X       : 450
Y       : 160
CX      : 90
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 16
Local : 1
OrigTitle : EditText16

#Control: LText17
AWindow : 30
X       : 0
Y       : 180
CX      : 360
CY      : 20
ControlLayer: 0
Title   : Botmaker,  The only verified legitimate download mpgh.net.
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 17
Local : 1
OrigTitle : LText17

